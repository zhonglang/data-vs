<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŸå¸‚æ•°æ®å¯¹æ¯”è§†é¢‘ç”Ÿæˆå™¨</title>
    <style>
        :root {
            --bg-color: #0b0f1f;
            --panel-bg: rgba(14, 18, 32, 0.88);
            --text-color: #e6f1ff;
            --accent-color: #2ee0ff;
            --accent-2: #7c3aed;
            --border-color: rgba(46, 224, 255, 0.2);
            --preview-width: 450px;
            --preview-height: 800px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: radial-gradient(1200px 800px at 20% 10%, rgba(46,224,255,0.12), transparent 60%),
                        radial-gradient(900px 700px at 90% 20%, rgba(124,58,237,0.18), transparent 55%),
                        linear-gradient(180deg, #090c1a 0%, #0b1024 100%);
            color: var(--text-color);
            font-family: 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        /* å¸ƒå±€å®¹å™¨ */
        .layout {
            display: flex;
            width: 100%;
            height: 100%;
        }

        /* å·¦ä¾§é…ç½®é¢æ¿ */
        .config-panel {
            width: 420px;
            background-color: var(--panel-bg);
            border-right: 1px solid var(--border-color);
            padding: 22px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            overflow-y: auto;
            z-index: 10;
            box-shadow: 0 0 30px rgba(0,0,0,0.5), inset 0 0 30px rgba(46,224,255,0.06);
            backdrop-filter: blur(16px) saturate(150%);
        }

        .config-group {
            border-bottom: 1px solid rgba(255,255,255,0.06);
            padding-bottom: 16px;
        }

        .config-group h3 {
            margin-bottom: 10px;
            font-size: 0.95rem;
            color: #9fb3d9;
            text-transform: uppercase;
            letter-spacing: 1.6px;
        }

        label {
            display: block;
            margin-bottom: 6px;
            font-size: 0.85rem;
            color: #b9c8e6;
        }

        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 10px 12px;
            background: rgba(8, 12, 24, 0.8);
            border: 1px solid rgba(46,224,255,0.25);
            color: #e6f1ff;
            border-radius: 8px;
            margin-bottom: 10px;
            font-family: inherit;
            box-shadow: inset 0 0 12px rgba(46,224,255,0.05);
        }

        textarea {
            height: 140px;
            resize: vertical;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.82rem;
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        button {
            padding: 10px 12px;
            background: linear-gradient(135deg, rgba(46,224,255,0.9), rgba(124,58,237,0.9));
            border: 1px solid rgba(46,224,255,0.35);
            color: #f2f7ff;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            letter-spacing: 0.3px;
            box-shadow: 0 0 16px rgba(46,224,255,0.25);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        button:hover { transform: translateY(-1px); box-shadow: 0 0 22px rgba(46,224,255,0.4); }
        button:disabled { background: #555; cursor: not-allowed; }
        
        .btn-danger { background: linear-gradient(135deg, #ff4d6d, #ff1f3d); }
        .btn-success { background: linear-gradient(135deg, #12d6a7, #00b3ff); }

        /* å³ä¾§é¢„è§ˆåŒºåŸŸ */
        .preview-area {
            flex: 1;
            background-color: #05070f;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            background-image:
                radial-gradient(600px 600px at 20% 30%, rgba(46,224,255,0.08), transparent 60%),
                radial-gradient(500px 500px at 80% 70%, rgba(124,58,237,0.12), transparent 55%),
                linear-gradient(135deg, rgba(255,255,255,0.04) 25%, transparent 25%),
                linear-gradient(-135deg, rgba(255,255,255,0.04) 25%, transparent 25%);
            background-size: auto, auto, 26px 26px, 26px 26px;
            background-position: 0 0, 0 0, 0 0, 13px 13px;
            overflow: hidden;
        }

        /* è§†é¢‘å†…å®¹æ ·å¼ - Canvas å®¹å™¨ */
        #video-stage {
            width: var(--preview-width);
            height: var(--preview-height);
            background: linear-gradient(180deg, #0b1328 0%, #0c1936 100%);
            position: relative;
            box-shadow: 0 0 80px rgba(0,0,0,0.6), 0 0 40px rgba(46,224,255,0.15);
            overflow: hidden;
            transform-origin: center center;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid rgba(46,224,255,0.25);
            border-radius: 4px; /* Canvas ä¸éœ€è¦å¤§åœ†è§’ï¼Œæˆ–è€…ä¿æŒä¸€è‡´ */
        }

        #main-canvas {
            display: block;
            /* ç¡®ä¿ canvas ä¸ä¼šæœ‰é¢å¤–è¾¹è· */
        }

        /* å½•åˆ¶çŠ¶æ€æç¤º */
        #recording-status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 70, 94, 0.9);
            color: white;
            padding: 6px 12px;
            border-radius: 999px;
            display: none;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(255,70,94,0.5);
            letter-spacing: 0.5px;
        }
        .blink { animation: blinker 1.5s linear infinite; }
        @keyframes blinker { 50% { opacity: 0.2; } }

        @keyframes shimmer {
            0% { filter: drop-shadow(0 0 6px rgba(46,224,255,0.2)); }
            50% { filter: drop-shadow(0 0 16px rgba(124,58,237,0.35)); }
            100% { filter: drop-shadow(0 0 6px rgba(46,224,255,0.2)); }
        }

        @keyframes scan {
            0% { transform: translateY(-40%); }
            100% { transform: translateY(40%); }
        }

    </style>
</head>
<body>

<div class="layout">
    <!-- å·¦ä¾§é…ç½® -->
    <div class="config-panel">
        <h2 style="margin-bottom:20px; color:#e6f1ff; letter-spacing:1px;">ğŸ›  é…ç½®é¢æ¿</h2>

        <div class="config-group">
            <h3>1. æ•°æ®å½•å…¥</h3>
            <label>JSON æ•°æ®:</label>
            <textarea id="json-input" placeholder='{"çœA": {"åŸ1": 100...}, "çœB": {...}}'></textarea>
            <button onclick="parseData()">è§£ææ•°æ®</button>
        </div>

        <div class="config-group" id="data-select-group" style="display:none;">
            <h3>2. å¯¹æ¯”è®¾ç½®</h3>
            <label>å·¦ä¾§åˆ—è¡¨ (Left):</label>
            <select id="select-left"></select>
            <label>å³ä¾§åˆ—è¡¨ (Right):</label>
            <select id="select-right"></select>
        </div>

        <div class="config-group">
            <h3>3. æ ·å¼ & æ ‡é¢˜</h3>
            <label>ä¸»æ ‡é¢˜:</label>
            <input type="text" id="input-title" value="2023å¹´ GDP å¤§æ¯”æ‹¼" oninput="updateTitle()">
            <label>å‰¯æ ‡é¢˜:</label>
            <input type="text" id="input-subtitle" value="å¹¿ä¸œ VS æ±Ÿè‹" oninput="updateTitle()">
            
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
                <div>
                    <label>èƒŒæ™¯è‰² (ä¸Š):</label>
                    <input type="color" id="bg-color-1" value="#1e1e2f" style="width:100%; height:30px;" onchange="updateStyle()">
                </div>
                <div>
                    <label>èƒŒæ™¯è‰² (ä¸‹):</label>
                    <input type="color" id="bg-color-2" value="#2a2a40" style="width:100%; height:30px;" onchange="updateStyle()">
                </div>
            </div>
        </div>

        <div class="config-group">
            <h3>4. åŠ¨ç”»æ§åˆ¶</h3>
            <label>æ¯è¡Œé—´éš” (ç§’):</label>
            <input type="number" id="interval-input" value="1.5" step="0.1" min="0.5">
            <label>è‡ªåŠ¨æ»šåŠ¨:</label>
            <select id="scroll-mode">
                <option value="auto">æ™ºèƒ½æ»šåŠ¨ (ä¿æŒæœ€æ–°åœ¨åº•éƒ¨)</option>
                <option value="page">ç¿»é¡µæ¨¡å¼ (æš‚æœªå®ç°)</option>
            </select>
        </div>

        <div class="config-group">
            <h3>5. å¯¼å‡º/æ“ä½œ</h3>
            <div class="btn-group">
                <button class="btn-success" id="btn-play" onclick="startAnimation()">â–¶ å¼€å§‹æ’­æ”¾</button>
                <button class="btn-danger" id="btn-export" onclick="exportVideo()">ï¿½ å¯¼å‡ºè§†é¢‘</button>
            </div>
            <button onclick="resetStage()" style="margin-top:10px; background:#666;">â†º é‡ç½®èˆå°</button>
            <p style="font-size:0.8rem; color:#888; margin-top:5px;">
                * å¯¼å‡ºä»…åŒ…å«å³ä¾§ 9:16 é¢„è§ˆåŒºåŸŸçš„è§†é¢‘å†…å®¹ï¼ˆé€‚é…è‡ªåª’ä½“ï¼‰ã€‚
            </p>
        </div>
    </div>

    <!-- å³ä¾§é¢„è§ˆ -->
    <div class="preview-area" id="preview-area">
        <div id="recording-status"><span class="blink">â—</span> å½•åˆ¶ä¸­...</div>
        
        <div id="video-stage">
            <canvas id="main-canvas" width="450" height="800"></canvas>
        </div>
    </div>
</div>

<script>
    // é»˜è®¤æ•°æ®
    const defaultData = { 
       "å¹¿ä¸œçœ": { 
         "æ·±åœ³å¸‚": 38731.8, "å¹¿å·å¸‚": 32039.46, "ä½›å±±å¸‚": 13157.35, "ä¸œèå¸‚": 12760.2, 
         "æƒ å·å¸‚": 6363.66, "ç æµ·å¸‚": 4573.1, "æ±Ÿé—¨å¸‚": 4293.91, "ä¸­å±±å¸‚": 4260.56, 
         "èŒ‚åå¸‚": 4106.4, "æ¹›æ±Ÿå¸‚": 3952.94, "æ±•å¤´å¸‚": 3023.83, "è‚‡åº†å¸‚": 2974.84, 
         "æ­é˜³å¸‚": 2553.75, "æ¸…è¿œå¸‚": 2317.47
       }, 
       "æ±Ÿè‹çœ": { 
         "è‹å·å¸‚": 27695.1, "å—äº¬å¸‚": 19428.78, "æ— é”¡å¸‚": 16773.94, "å—é€šå¸‚": 12801.5, 
         "å¸¸å·å¸‚": 11158.7, "å¾å·å¸‚": 9957.22, "ç›åŸå¸‚": 8045.3, "æ‰¬å·å¸‚": 8056.75, 
         "æ³°å·å¸‚": 7255.27, "é•‡æ±Ÿå¸‚": 5736.78, "æ·®å®‰å¸‚": 5630.11, "è¿äº‘æ¸¯å¸‚": 4830.94, 
         "å®¿è¿å¸‚": 5026.6 
       } 
    };

    let rawData = {};
    let compareList = [];
    
    // Canvas & Animation State
    const CANVAS_WIDTH = 450;
    const CANVAS_HEIGHT = 800;
    let canvas, ctx;
    let rafId = null;
    let isAnimating = false;
    let startTime = 0;
    
    // Recording State
    let mediaRecorder = null;
    let recordedChunks = [];
    let isRecording = false;

    // Timeline Configuration
    let timeline = {};

    // åˆå§‹åŒ–
    window.onload = () => {
        canvas = document.getElementById('main-canvas');
        ctx = canvas.getContext('2d');

        document.getElementById('json-input').value = JSON.stringify(defaultData, null, 2);
        parseData(); // è‡ªåŠ¨è§£æ
        resizeStage(); // é€‚é…å±å¹•
        window.addEventListener('resize', resizeStage);
        
        // åˆå§‹ç»˜åˆ¶
        drawStatic();
    };

    function resizeStage() {
        const container = document.getElementById('preview-area');
        const stage = document.getElementById('video-stage');
        const padding = 40;
        
        const availWidth = container.clientWidth - padding;
        const availHeight = container.clientHeight - padding;
        
        const scale = Math.min(availWidth / CANVAS_WIDTH, availHeight / CANVAS_HEIGHT);
        
        stage.style.transform = `scale(${scale})`;
    }

    function parseData() {
        try {
            const input = document.getElementById('json-input').value;
            rawData = JSON.parse(input);
            const keys = Object.keys(rawData);
            
            if (keys.length < 2) {
                alert("æ•°æ®è‡³å°‘éœ€è¦ä¸¤ä¸ªåˆ†ç±»");
                return;
            }

            const selLeft = document.getElementById('select-left');
            const selRight = document.getElementById('select-right');
            selLeft.innerHTML = '';
            selRight.innerHTML = '';

            keys.forEach(k => {
                selLeft.add(new Option(k, k));
                selRight.add(new Option(k, k));
            });
            
            // é»˜è®¤é€‰å‰ä¸¤ä¸ª
            selLeft.selectedIndex = 0;
            selRight.selectedIndex = 1;
            
            document.getElementById('data-select-group').style.display = 'block';
            
            // è‡ªåŠ¨æ›´æ–°å‰¯æ ‡é¢˜
            document.getElementById('input-subtitle').value = `${keys[0]} VS ${keys[1]}`;
            updateTitle();

        } catch (e) {
            alert("JSON é”™è¯¯: " + e.message);
        }
    }

    function updateTitle() {
        // Canvas æ¨¡å¼ä¸‹ï¼Œæ›´æ–°æ ‡é¢˜åªéœ€é‡ç»˜
        drawStatic();
    }

    function updateStyle() {
        // Canvas æ¨¡å¼ä¸‹ï¼Œæ›´æ–°æ ·å¼åªéœ€é‡ç»˜
        drawStatic();
    }

    function processDataList(key) {
        const data = rawData[key];
        let list = [];
        if (Array.isArray(data)) {
            list = data.map(item => {
                const nameKey = Object.keys(item).find(k => !['value','å€¼'].includes(k)) || Object.keys(item)[0];
                const valKey = Object.keys(item).find(k => ['value','val','å€¼'].includes(k)) || Object.keys(item)[1];
                return { name: item[nameKey], value: parseFloat(item[valKey]) || 0 };
            });
        } else {
            list = Object.entries(data).map(([k,v]) => ({ name: k, value: parseFloat(v) || 0 }));
        }
        return list.sort((a,b) => b.value - a.value);
    }

    function prepareCompareData() {
        const k1 = document.getElementById('select-left').value;
        const k2 = document.getElementById('select-right').value;
        
        if (k1 === k2) {
            alert("è¯·é€‰æ‹©ä¸åŒçš„å¯¹æ¯”é¡¹");
            return false;
        }

        const list1 = processDataList(k1);
        const list2 = processDataList(k2);
        const maxLen = Math.max(list1.length, list2.length);

        compareList = [];
        for(let i=0; i<maxLen; i++) {
            compareList.push({
                rank: i + 1,
                left: list1[i] || { name: '-', value: 0 },
                right: list2[i] || { name: '-', value: 0 }
            });
        }
        return true;
    }

    function resetStage() {
        if (rafId) cancelAnimationFrame(rafId);
        isAnimating = false;
        isRecording = false;
        document.getElementById('recording-status').style.display = 'none';
        drawStatic();
    }

    // ç»˜åˆ¶é™æ€å¸§ï¼ˆèƒŒæ™¯+æ ‡é¢˜ï¼‰
    function drawStatic() {
        if (isAnimating) return;
        drawFrame(0, true);
    }

    // --- æ ¸å¿ƒåŠ¨ç”»å¾ªç¯ ---
    function startAnimation(record = false) {
        if (!prepareCompareData()) return;
        
        // åœæ­¢ä¹‹å‰çš„åŠ¨ç”»
        if (rafId) cancelAnimationFrame(rafId);
        
        isAnimating = true;
        isRecording = record;
        startTime = performance.now();
        
        // è®¡ç®—æ—¶é—´è½´
        const interval = parseFloat(document.getElementById('interval-input').value) * 1000;
        const totalItems = compareList.length;
        
        // åŠ¨ç”»å‚æ•°é…ç½®
        const T_BAR_DELAY = 300;
        const T_BAR_DURATION = 1000;
        const T_BOTTOM_HOLD = 1000; // åº•éƒ¨åœç•™
        const T_SCROLL_BACK = 1500; // å›æ»š
        const T_TOP_HOLD = 1500;    // é¡¶éƒ¨åœç•™

        // Phase 1: å±•ç¤ºå†…å®¹
        const t_last_item_start = Math.max(0, totalItems - 1) * interval;
        const t_content_end = t_last_item_start + T_BAR_DELAY + T_BAR_DURATION;

        // å®šä¹‰å…³é”®æ—¶é—´ç‚¹
        timeline = {
            interval,
            totalItems,
            phase1_show: t_content_end,
            phase2_bottom: t_content_end + T_BOTTOM_HOLD,
            phase3_scroll: t_content_end + T_BOTTOM_HOLD + T_SCROLL_BACK,
            phase4_top: t_content_end + T_BOTTOM_HOLD + T_SCROLL_BACK + T_TOP_HOLD,
            totalDuration: t_content_end + T_BOTTOM_HOLD + T_SCROLL_BACK + T_TOP_HOLD
        };

        if (isRecording) {
            setupRecorder();
        }

        loop();
    }

    // å¯¼å‡ºè§†é¢‘å…¥å£
    function exportVideo() {
        startAnimation(true);
    }

    function setupRecorder() {
        const recBadge = document.getElementById('recording-status');
        recBadge.style.display = 'flex';
        
        // ç¡®ä¿æ•è·æµå¸§ç‡è¶³å¤Ÿ
        const stream = canvas.captureStream(60);
        
        let mimeType = 'video/webm';
        if (MediaRecorder.isTypeSupported('video/mp4;codecs=avc1')) {
            mimeType = 'video/mp4;codecs=avc1';
        } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
            mimeType = 'video/webm;codecs=vp9';
        }

        console.log(`[Export] Start recording. MIME: ${mimeType}`);

        mediaRecorder = new MediaRecorder(stream, {
            mimeType,
            videoBitsPerSecond: 8000000 // 8Mbps
        });
        
        recordedChunks = [];
        mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
        mediaRecorder.onstop = () => {
            console.log(`[Export] Recorder stopped. Chunks: ${recordedChunks.length}`);
            const blob = new Blob(recordedChunks, { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            const ext = mimeType.includes('mp4') ? 'mp4' : 'webm';
            a.download = `video_stage_${Date.now()}.${ext}`;
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(url);
            
            cleanupRecording();
        };
        
        mediaRecorder.start();
    }

    function loop() {
        if (!isAnimating) return;

        const now = performance.now();
        let elapsed = now - startTime;

        // æ£€æŸ¥æ˜¯å¦ç»“æŸ
        if (elapsed >= timeline.totalDuration) {
            elapsed = timeline.totalDuration;
            drawFrame(elapsed); // æ¸²æŸ“æœ€åä¸€å¸§
            stopAnimation();
            return;
        }

        drawFrame(elapsed);
        rafId = requestAnimationFrame(loop);
    }

    function stopAnimation() {
        isAnimating = false;
        if (rafId) cancelAnimationFrame(rafId);
        
        if (isRecording && mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
        } else {
            // å¦‚æœä¸æ˜¯å½•åˆ¶æ¨¡å¼ï¼Œç›´æ¥ç»“æŸ
            if (isRecording) cleanupRecording();
        }
    }

    function cleanupRecording() {
        isRecording = false;
        document.getElementById('recording-status').style.display = 'none';
        // åŠ¨ç”»ç»“æŸåï¼Œå¯ä»¥åœç•™åœ¨æœ€åä¸€å¸§ï¼Œæˆ–è€…é‡ç½®
        // è¿™é‡Œé€‰æ‹©åœç•™åœ¨æœ€åä¸€å¸§ï¼Œç›´åˆ°ç”¨æˆ·ç‚¹å‡»é‡ç½®
    }

    // --- ç»Ÿä¸€æ¸²æŸ“å‡½æ•° ---
    function drawFrame(elapsed, staticMode = false) {
        // æ¸…ç©ºç”»å¸ƒ
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // 1. èƒŒæ™¯ç»˜åˆ¶
        const c1 = document.getElementById('bg-color-1').value;
        const c2 = document.getElementById('bg-color-2').value;
        const bg = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
        bg.addColorStop(0, c1);
        bg.addColorStop(1, c2);
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // è¾¹æ¡†
        ctx.strokeStyle = 'rgba(46,224,255,0.25)';
        ctx.lineWidth = 1;
        ctx.strokeRect(0.5, 0.5, CANVAS_WIDTH - 1, CANVAS_HEIGHT - 1);

        // 2. å¤´éƒ¨ç»˜åˆ¶
        const headerH = 110;
        ctx.fillStyle = 'rgba(9,14,30,0.7)';
        ctx.fillRect(0, 0, CANVAS_WIDTH, headerH);
        ctx.strokeStyle = 'rgba(46,224,255,0.25)';
        ctx.beginPath();
        ctx.moveTo(0, headerH + 0.5);
        ctx.lineTo(CANVAS_WIDTH, headerH + 0.5);
        ctx.stroke();

        // æ ‡é¢˜
        const title = document.getElementById('input-title').value;
        const subtitle = document.getElementById('input-subtitle').value;
        
        const titleGrad = ctx.createLinearGradient(0, 0, CANVAS_WIDTH, 0);
        titleGrad.addColorStop(0, '#7cf9ff');
        titleGrad.addColorStop(0.5, '#7c3aed');
        titleGrad.addColorStop(1, '#00f2fe');
        ctx.fillStyle = titleGrad;
        ctx.font = '800 32px Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(title, CANVAS_WIDTH / 2, 42);

        ctx.fillStyle = '#a7b4d6';
        ctx.font = '16px Segoe UI, Roboto, sans-serif';
        ctx.fillText(subtitle, CANVAS_WIDTH / 2, 78);

        // å¦‚æœæ˜¯é™æ€æ¨¡å¼ï¼ˆä»…èƒŒæ™¯ï¼‰ï¼Œç›´æ¥è¿”å›
        if (staticMode) return;

        // 3. åˆ—è¡¨å†…å®¹ç»˜åˆ¶
        const listTop = headerH + 12;
        const rowHeight = 74;
        const gap = 12;
        const contentPadding = 12;
        const rowStep = rowHeight + gap;
        
        // è®¡ç®—å¯è§†åŒºåŸŸèƒ½å®¹çº³å¤šå°‘è¡Œ
        const maxVisible = Math.floor((CANVAS_HEIGHT - listTop - contentPadding) / rowStep);
        
        // --- æ»šåŠ¨ä½ç½®è®¡ç®— ---
        let currentScroll = 0;
        let rowsToDraw = 0;

        const { interval, totalItems, phase1_show, phase2_bottom, phase3_scroll } = timeline;

        if (elapsed < phase1_show) {
            // [é˜¶æ®µ1: å±•ç¤º]
            rowsToDraw = Math.min(totalItems, Math.floor(elapsed / interval) + 1);
            const overflowCount = Math.max(0, rowsToDraw - maxVisible);
            currentScroll = -overflowCount * rowStep;
            
        } else if (elapsed < phase2_bottom) {
            // [é˜¶æ®µ2: åº•éƒ¨åœç•™]
            rowsToDraw = totalItems;
            const overflowCount = Math.max(0, totalItems - maxVisible);
            currentScroll = -overflowCount * rowStep;
            
        } else if (elapsed < phase3_scroll) {
            // [é˜¶æ®µ3: å›æ»šé¡¶éƒ¨]
            rowsToDraw = totalItems;
            const maxScroll = -Math.max(0, totalItems - maxVisible) * rowStep;
            
            // è®¡ç®—å›æ»šè¿›åº¦ (0 -> 1)
            const t = (elapsed - phase2_bottom) / (phase3_scroll - phase2_bottom);
            const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2; // EaseInOutQuad
            
            // ä» maxScroll å˜å›åˆ° 0
            currentScroll = maxScroll * (1 - ease);
            
        } else {
            // [é˜¶æ®µ4: é¡¶éƒ¨åœç•™]
            rowsToDraw = totalItems;
            currentScroll = 0;
        }

        // ç»˜åˆ¶æ¯ä¸€è¡Œ
        for (let i = 0; i < rowsToDraw; i++) {
            const item = compareList[i];
            const yBase = listTop + i * rowStep + currentScroll;
            
            // è§†å£å‰”é™¤ä¼˜åŒ–
            if (yBase > CANVAS_HEIGHT || yBase + rowHeight < listTop) continue;

            drawRow(yBase, rowHeight, contentPadding, item, i, elapsed, interval);
        }
    }

    function drawRow(y, h, padding, item, index, elapsed, interval) {
        // è¿›åœºåŠ¨ç”»è®¡ç®—
        const startTime = index * interval;
        let p = Math.min((elapsed - startTime) / 500, 1);
        p = Math.max(0, p);
        const ease = p < 1 ? (1 - Math.pow(1 - p, 3)) : 1; // EaseOutCubic

        const currentY = y + (1 - ease) * 20; // ä¸Šæµ®
        const alpha = ease;

        ctx.globalAlpha = alpha;

        // è¡ŒèƒŒæ™¯
        const rowGrad = ctx.createLinearGradient(0, currentY, CANVAS_WIDTH, currentY);
        rowGrad.addColorStop(0, 'rgba(9,14,30,0.8)');
        rowGrad.addColorStop(1, 'rgba(13,22,44,0.9)');
        ctx.fillStyle = rowGrad;
        ctx.strokeStyle = 'rgba(46,224,255,0.2)';
        ctx.lineWidth = 1;
        ctx.fillRect(padding, currentY, CANVAS_WIDTH - padding * 2, h);
        ctx.strokeRect(padding + 0.5, currentY + 0.5, CANVAS_WIDTH - padding * 2 - 1, h - 1);

        // ä¸­çº¿
        ctx.fillStyle = 'rgba(46,224,255,0.35)';
        ctx.fillRect(CANVAS_WIDTH / 2 - 1, currentY, 2, h);

        // å†…å®¹è®¡ç®—
        const halfW = CANVAS_WIDTH / 2;
        const leftRect = [padding, currentY, halfW - padding, h];
        const rightRect = [halfW, currentY, halfW - padding, h];

        const lVal = item.left.value || 0;
        const rVal = item.right.value || 0;
        const maxVal = Math.max(lVal, rVal) || 1;
        const lPct = lVal / maxVal;
        const rPct = rVal / maxVal;

        // èƒœè´ŸèƒŒæ™¯
        if (lVal > rVal) {
            ctx.fillStyle = 'rgba(0,242,254,0.18)';
            ctx.fillRect(leftRect[0], leftRect[1], leftRect[2], leftRect[3]);
        } else if (rVal > lVal) {
            ctx.fillStyle = 'rgba(255,75,31,0.18)';
            ctx.fillRect(rightRect[0], rightRect[1], rightRect[2], rightRect[3]);
        }

        // æ–‡æœ¬
        ctx.fillStyle = '#e6f1ff';
        ctx.font = '700 16px Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(item.left.name, leftRect[0] + leftRect[2] / 2, currentY + 22);
        ctx.fillText(item.right.name, rightRect[0] + rightRect[2] / 2, currentY + 22);

        ctx.font = '28px Impact, sans-serif';
        ctx.fillText(lVal.toLocaleString(), leftRect[0] + leftRect[2] / 2, currentY + 50);
        ctx.fillText(rVal.toLocaleString(), rightRect[0] + rightRect[2] / 2, currentY + 50);

        // è¿›åº¦æ¡åŠ¨ç”» (åœ¨è¡Œå‡ºç°å 300ms å¼€å§‹)
        const barStart = startTime + 300;
        const barAnim = Math.max(0, Math.min((elapsed - barStart) / 1000, 1));
        const barEase = barAnim < 1 ? (1 - Math.pow(1 - barAnim, 2)) : 1;

        // å·¦æ¡
        ctx.fillStyle = '#00f2fe';
        const lBarW = leftRect[2] * lPct * barEase;
        ctx.fillRect(leftRect[0] + leftRect[2] * (1 - lPct * barEase), currentY + h - 6, lBarW, 5);

        // å³æ¡
        ctx.fillStyle = '#ff4b1f';
        const rBarW = rightRect[2] * rPct * barEase;
        ctx.fillRect(rightRect[0], currentY + h - 6, rBarW, 5);

        // æ’åå¾½ç« 
        const badgeW = 68;
        const badgeH = 24;
        const badgeX = CANVAS_WIDTH / 2 - badgeW / 2;
        const badgeY = currentY + h / 2 - badgeH / 2;
        
        ctx.fillStyle = 'rgba(10,16,32,0.7)';
        ctx.strokeStyle = 'rgba(46,224,255,0.35)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        const r = badgeH / 2;
        ctx.moveTo(badgeX + r, badgeY);
        ctx.arc(badgeX + badgeW - r, badgeY + r, r, -Math.PI / 2, Math.PI / 2);
        ctx.arc(badgeX + r, badgeY + r, r, Math.PI / 2, -Math.PI / 2);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = '#cfe9ff';
        ctx.font = '700 12px Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`ç¬¬${item.rank}å`, CANVAS_WIDTH / 2, currentY + h / 2);

        ctx.globalAlpha = 1;
    }

</script>
</body>
</html>
